#!/usr/bin/env nodejs

var AWS = require('aws-sdk');
var aws_bucket='mlscratch';

function print_usage() {
	console.log ('Usage:');
	console.log ('mlcp --list s3://bucketname/path --ticket=[ticket]');
	console.log ('mlcp /path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat /path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --move s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --remove s3://bucketname/path/to/file.dat --ticket=[ticket]');
	console.log ('mlcp --prv-locate s3://bucketname /path/to/file.prv');
	console.log ('mlcp --prv-create s3://bucketname/path/to/file.dat /path/to/file.dat.prv');

	return;
}

var server_url='https://mlcps.herokuapp.com';
//var server_url='http://localhost:8012';

var CLP=new CLParams(process.argv);

if ('mlcps' in CLP.namedParameters)
	server_url=CLP.namedParameters['mlcps'];

var ticket=CLP.namedParameters['ticket']||'';

if ((CLP.unnamedParameters.length===0)&&(!ticket)) {
	print_usage();
	return;
}

var settings = require('user-settings').file('.mlcp');
if (!ticket) {
	ticket=settings.get('ticket');
}
if (!ticket) {
	print_usage();
	return;
}
settings.set('ticket',ticket);

if ('prv-locate' in CLP.namedParameters) {
	var addr1=CLP.unnamedParameters[0]||'';
	var addr2=CLP.unnamedParameters[1]||'';
	var prv_addr,bucket_addr;
	if (starts_with(addr1,'s3://')) {
		bucket_addr=addr1; prv_addr=addr2;
	}
	else {
		prv_addr=addr1; bucket_addr=addr2;
	}
	if (!ends_with(prv_addr,'.prv')) {
		print_usage();
		return;
	}
	if (!starts_with(bucket_addr,'s3://')) {
		print_usage();
		return;
	}
	var bucket=get_bucket_from_s3_address(bucket_addr);
	var prv=read_json_object(prv_addr);
	var req={
		bucket:bucket,
		sha1:prv.original_checksum,
		size:prv.original_size
	};
	http_post_json(server_url+'/api/prv_locate',req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error making request: '+tmp.error);
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			return;
		}
		if (!obj.found) {
			console.log('Not found: '+obj.message);
			return;
		}
		console.log (obj.path);
	});
	return;
}
else if ('prv-create' in CLP.namedParameters) {
	var addr1=CLP.unnamedParameters[0]||'';
	var addr2=CLP.unnamedParameters[1]||'';
	var prv_addr,remote_addr;
	if (starts_with(addr1,'s3://')) {
		remote_addr=addr1; prv_addr=addr2;
	}
	else {
		prv_addr=addr1; remote_addr=addr2;
	}
	if (!ends_with(prv_addr,'.prv')) {
		print_usage();
		return;
	}
	if (!starts_with(remote_addr,'s3://')) {
		print_usage();
		return;
	}
	var bucket=get_bucket_from_s3_address(remote_addr);
	var remote_path=get_path_from_s3_address(remote_addr);
	var req={
		bucket:bucket,
		path:remote_path
	};
	http_post_json(server_url+'/api/prv_stat',req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error making request: '+tmp.error);
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			return;
		}
		var prv={
			original_checksum:obj.sha1,
			original_fcs:obj.fcs,
			original_size:obj.size,
			original_path:remote_addr,
			prv_version:"0.11"
		};
		write_json_object(prv_addr,prv);
	});
	return;
}

get_credentials_for_ticket(ticket,function() {
	if ('list' in CLP.namedParameters) {
		var address=CLP.unnamedParameters[0]||'';
		if (!address) {
			print_usage();
			return;
		}
		do_list(address,function() {
		});
	}
	else if ('remove' in CLP.namedParameters) {
		var address=CLP.unnamedParameters[0]||'';
		if (!address) {
			print_usage();
			return;
		}
		do_remove(address,function() {
		});
	}
	else {
		var src_address=CLP.unnamedParameters[0]||'';
		var dst_address=CLP.unnamedParameters[1]||'';

		if ((!src_address)||(!dst_address)) {
			print_usage();
			return;
		}

		if ((starts_with(dst_address,'s3://'))&&(!starts_with(src_address,'s3://'))) {
			do_upload(src_address,dst_address,function() {
				process.exit(0); //do this because of request-progress waiting for next timeout
			});
		}
		else if ((starts_with(src_address,'s3://'))&&(!starts_with(dst_address,'s3://'))) {
			do_download(src_address,dst_address,function() {
				process.exit(0); //do this because of request-progress waiting for next timeout
			});
		}
		else if ((starts_with(src_address,'s3://'))&&(starts_with(dst_address,'s3://'))) {
			if ('move' in CLP.namedParameters) {
				do_copy_or_move('move',src_address,dst_address,function() {
				});
			}
			else {
				do_copy_or_move('copy',src_address,dst_address,function() {
				});
			}
		}
		else {
			print_usage();
			return;
		}
	}
});

function get_credentials_for_ticket(ticket,callback) {
	var url=server_url+'/api/get_credentials';
	http_post_json(url,{ticket:ticket},{},function(tmp) {
		if (!tmp.success) {
			console.log ('Error getting credentials: '+tmp.error);
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.log ('Error in get_credentials: '+obj.error);
			return;
		}

		AWS.config.credentials=new AWS.Credentials({
			accessKeyId:obj.credentials.AccessKeyId,
			secretAccessKey:obj.credentials.SecretAccessKey,
			sessionToken:obj.credentials.SessionToken
		});
		callback({success:true});
	});
	//callback();
}

function do_list(address,cb) {
	var s3 = new AWS.S3({apiVersion: '2006-03-01'});
	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);

	s3.listObjects({Bucket:bucket,Prefix:path+'/',Delimiter:'/'},function(err,data) {
		if (err) {
			console.error('Error listing folder '+path+' in bucket '+bucket+': '+err.code);
			return;
		}
		var subdirs=[];
		for (var i in data.CommonPrefixes) {
			var tmp=data.CommonPrefixes[i].Prefix;
			var tmp2=tmp.split('/');
			subdirs.push(tmp2[tmp2.length-2]);
		}
		var files=[];
		var contents=data.Contents;
		for (var i in contents) {
			var C=contents[i];
			var file0={
				name:C.Key.slice((path+'/').length),
				size:C.Size
			};
			files.push(file0);
		}
		for (var i in subdirs) {
			console.log (subdirs[i]+'/');
		}
		for (var i in files) {
			var size0=format_file_size(files[i].size);
			console.log (files[i].name+' ('+size0+')');
		}
	});
}

function do_copy_or_move(str,src_address,dst_address,cb) {
	var s3 = new AWS.S3({apiVersion: '2006-03-01'});
	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	if (src_bucket!=dst_bucket) {
		console.error('Cannot copy between buckets');
		return;
	}
	console.log ('Copying object: '+'/'+src_bucket+'/'+src_path+' to '+'/'+dst_bucket+'/'+dst_path);
	s3.copyObject({Bucket:dst_bucket,CopySource:'/'+src_bucket+'/'+src_path,Key:dst_path},function(err,data) {
		if (err) {
			console.error('Error copying object: '+err.code);
			return;
		}
		console.log ('Done.');
		if (str=='move') {
			console.log ('Deleting object: /'+src_bucket+'/'+src_path);
			s3.deleteObject({Bucket:src_bucket,Key:src_path},function(err2,data2) {
				if (err2) {
					console.error('Error removing source object: '+err2.code);
					return;
				}
				console.log ('Done');
				return;
			});
		}
		else {
			return;
		}
	});
}

function do_remove(address,cb) {
	var s3 = new AWS.S3({apiVersion: '2006-03-01'});

	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);
	s3.deleteObject({Bucket:bucket,Key:path},function(err1,data1) {
		if (err1) {
			console.error('Error removing object: '+err1.code);
			return;
		}
	});
}

function do_upload(src_address,dst_address,cb) {
	var s3 = new AWS.S3({apiVersion: '2006-03-01'});

	if (!file_exists(src_address)) {
		console.log ('Source file does not exist: '+src_address);
		return;
	}
	var src_size_bytes=file_size_bytes(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	var read_stream=require('fs').createReadStream(src_address);
	var RR=s3.upload({Bucket:dst_bucket,Key:dst_path,Body:read_stream},function(err,data) {
		if (err) {
			console.log ('Error in upload: '+err.code);
			return;
		}
		if (cb) cb();
	});

	RR.on('httpUploadProgress',function(aa) {
		var size1=format_file_size(aa.loaded);
		var size2=format_file_size(aa.total);
		var pct=Math.floor(aa.loaded/aa.total*100);
		console.log('Uploaded '+size1+' of '+size2+' ('+pct+'%)');
	});
}

function perform_single_upload(url,query,src_address,range,cb) {
	size_bytes=range[1]-range[0]+1;

	var form = new FormData();
	for (var field in query) {
		form.append(field,query[field]);
	}
	console.log ('uploading: '+src_address+' to '+dst_address);
	form.append('file', require('fs').createReadStream(src_address,{start:range[0],end:range[1]}));

	var done=false;
	var reqreq=form.submit(url, function(err, resp){
		if (err) {
			console.error('Error submitting upload: '+err.message);
			if (cb) cb({success:false,error:err.message}); cb=0;
		} else {
			var body='';
			resp.on('data',function(data) {
				body+=data.toString('utf-8');
			});
			resp.on('error',function(err) {
				console.log ('Error: '+err.message);
				if (cb) cb({success:false,error:err.message}); cb=0;
			});
			resp.on('end',function() {
				if (body.trim()) console.log (body);
				if (cb) {
					cb({success:true}); cb=0;
				}
			});
			//console.log('body: '+JSON.stringify(body));
		}
	});
	return reqreq;
}

function upload_part_summary_file(url,query,summary_info,cb) {
	var form = new FormData();
	for (var field in query) {
		form.append(field,query[field]);
	}
	form.append('file', JSON.stringify(summary_info));

	var done=false;
	console.log ('Uploading part summary file');
	form.submit(url, function(err, resp){
		if (err) {
			console.error('Error submitting summary file upload: '+err.message);
			if (cb) cb({success:false,error:err.message}); cb=0;
		} else {
			var body='';
			resp.on('data',function(data) {
				body+=data.toString('utf-8');
			});
			resp.on('error',function(err) {
				console.log ('Error: '+err.message);
				if (cb) cb({success:false,error:err.message}); cb=0;
			});
			resp.on('end',function() {
				if (body.trim()) console.log (body);
				if (cb) {
					cb({success:true}); cb=0;
				}
			});
		}
	});
}

function do_download(src_address,dst_address,callback) {
	var s3 = new AWS.S3({apiVersion: '2006-03-01'});
	var downloader = require('s3-download')(s3);

	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);

	s3.headObject({Bucket:src_bucket,Key:src_path},function(err,data) {
		if (err) {
			console.error('Error locating object '+src_path+' in bucket '+src_bucket+': '+err.code);
			return;
		}
		var size0=Number(data.ContentLength);
		var sessionParams = {
		    maxPartSize: 1024*1024*20,//default 20MB 
		    concurrentStreams: 8,//default 5 
		    maxRetries: 3,//default 3 
		    totalObjectSize: size0 //required size of object being downloaded 
		}

		var bytes_downloaded=0;
		var d = downloader.download({Bucket:src_bucket,Key:src_path},sessionParams);
		d.on('error',function(err){
		    console.error(err);
		});
		// dat = size_of_part_downloaded 
		d.on('part',function(dat){
			bytes_downloaded+=dat;
			var size1=format_file_size(bytes_downloaded);
			var size2=format_file_size(size0);
			var pct=Math.floor(bytes_downloaded/size0*100);
		    console.log('Downloaded '+size1+' of '+size2+' ('+pct+'%)');
		});
		d.on('downloaded',function(dat){
		    console.log (dat);
		});
		 
		var w = require('fs').createWriteStream(dst_address);
		d.pipe(w);
	});
}

function get_bucket_from_s3_address(str) {
	var list=str.split('/');
	return list[2]||'';
}

function get_path_from_s3_address(str) {
	var list=str.split('/');
	//todo: switch to leading /
	//return list.slice(3).join('/');
	return '/'+list.slice(3).join('/');
}

function http_post_json(url,data,headers,callback) {
	var post_data=JSON.stringify(data);

	var url_parts=require('url').parse(url);

	var options={
		method: "POST",
		hostname: url_parts.hostname,
		port:url_parts.port,
		path:url_parts.path
	};

	var http_module;
	if (url_parts.protocol=='https:')
		http_module=require('https');
	else if (url_parts.protocol=='http:')
		http_module=require('http');
	else {
		if (callback)
			callback({success:false,error:'invalid protocol for url: '+url});
		return;
	}

	if (headers) {
		options.headers=headers;
	}

	var req=http_module.request(options,handler);
	req.on('error',function(e) {
		if (callback) callback({success:false,error:'Error in post request: '+e});
		callback=null;
	});
	function handler(res) {
		var txt='';
		res.on('data', function(d) {
			txt+=d
		});
		req.on('error', function(e) {
		  if (callback) callback({success:false,error:'Error in post: '+e});
		  callback=null;
		});
		res.on('end', function() {
			var obj;
			try {
				obj=JSON.parse(txt);
			}
			catch(err) {
				console.log (txt);
				if (callback) callback({success:false,error:'Error parsing json response'});
				callback=null;
				return;
			}
			if (callback) callback({success:true,object:obj});
			callback=null;
		});
	}
	req.write(post_data);
	req.end();
}


function file_exists(path) {
	return require('fs').existsSync(path);
}

function file_size_bytes(path) {
	var stat=require('fs').statSync(path);
	return stat.size;
}


function CLParams(argv) {
	this.unnamedParameters=[];
	this.namedParameters={};

	var args=argv.slice(2);
	for (var i=0; i<args.length; i++) {
		var arg0=args[i];
		if (arg0.indexOf('--')===0) {
			arg0=arg0.slice(2);
			var ind=arg0.indexOf('=');
			if (ind>=0) {
				this.namedParameters[arg0.slice(0,ind)]=arg0.slice(ind+1);
			}
			else {
				//this.namedParameters[arg0]=args[i+1]||'';
				//i++;
				this.namedParameters[arg0]='';
			}
		}
		else if (arg0.indexOf('-')===0) {
			arg0=arg0.slice(1);
			this.namedParameters[arg0]='';
		}
		else {
			this.unnamedParameters.push(arg0);
		}
	}
};

function format_file_size(size_bytes) {
	size_bytes=Number(size_bytes);
	if (size_bytes>10e9) {
	  return Math.floor(size_bytes/1e9)+' GB';
	}
	else if (size_bytes>1e9) {
	  return Math.floor(size_bytes/1e8)/10+' GB';  
	}
	else if (size_bytes>10e6) {
	  return Math.floor(size_bytes/1e6)+' MB';
	}
	else if (size_bytes>1e6) {
	  return Math.floor(size_bytes/1e5)/10+' MB';  
	}
	else if (size_bytes>10e3) {
	  return Math.floor(size_bytes/1e3)+' KB';
	}
	else if (size_bytes>1e3) {
	  return Math.floor(size_bytes/1e2)/10+' KB';  
	}
	else {
	  return size_bytes+' bytes';
	}
}

function foreach(array,opts,step_function,end_function) {
	var num_parallel=opts.num_parallel||1;
	var num_running=0;
	var num_finished=0;
	var already_called_end=false;
	var ii=0;
	next_step();
	function next_step() {
		if (num_finished>=array.length) {
			setTimeout(function() { //important to do it this way so we don't accumulate a call stack
				if (!already_called_end) { 
					already_called_end=true;
					end_function();
				}
			},0);
			return;
		}
		while ((ii<array.length)&&(num_running<num_parallel)) {
			num_running++;
			ii++;
			step_function(ii-1,array[ii-1],function() {
				num_running--;
				num_finished++;
				setTimeout(function() { //important to do it this way so we don't accumulate a call stack
					next_step();
				},0);
			});
		}
	}
}


function mkdir_if_needed(path) {
	var fs=require('fs');
	if (!require('fs').existsSync(path)){
    	require('fs').mkdirSync(path);
	}
}

function starts_with(str,str2) {
	return (str.slice(0,str2.length)==str2);
}

function ends_with(str,str2) {
	return (str.slice(str.length-str2.length,str.length)==str2);
}

function read_json_object(path) {
	var fs=require('fs');
	var txt=fs.readFileSync(path,'utf-8');
	return JSON.parse(txt);
}

function write_json_object(path,obj) {
	require('fs').writeFileSync(path,JSON.stringify(obj,null,4),'utf-8');
}